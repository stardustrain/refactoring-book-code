# 3. 코드에서 나는 악취

## 1. 주요 내용 정리

Code smell의 유형

### 1. 기이한 이름

- 코드는 단순하고 명료하게 작성한다.
  - 이름만 보고서도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경쓴다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
  - 혼란스러운 이름을 정리하다보면 코드가 간결해 질떄가 많다.
- [함수 선언 바꾸기](함수선언바꾸기), [변수 이름 바꾸기](변수이름바꾸기), [필드 이름 바꾸기](필드이름바꾸기) 등의 기법을 사용한다.

### 2. 중복 코드

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
  - 예시로, 한 클래스에 속한 두 method가 똑같은 표현식을 사용한다면 [함수 추출하기](함수추출하기)를 이용해 양쪽 모두 추출된 method를 호출하게 수정한다.
  - 코드가 비슷한데 완전히 똑같지는 않다면 [문장 슬라이드하기]로 비슷한 부분을 한곳에 모아 함수를 추출한다.
  - 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면, [메서드 올리기](메서드올리기)를 적용해 부모로 메서드를 옮긴다.

### 3. 긴 함수

- 함수를 짧게 구성하면 코드를 이해하고 공유하고 선택하기 쉬워진다.
  - 이때도 함수의 이름을 잘 지어두면 본문의 코드를 볼 이유가 사라진다.
- 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
  - 함수의 본문에는 주석으로 설명하려던 코드가 담기고, **함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다**.
- 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가이다.
  - 즉, "무엇을 하는지"를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.
- 함수를 짧게 만드는 작업의 대부분은 [함수 추출하기](함수추출하기)가 차지한다.
- 함수가 매개변수와 임시변수를 많이 사용한다면 추출 작업에 방해가 된다.
  - [임시 변수를 질의 함수로 바꾸기](임시변수를질의함수로바꾸기)로 임시 변수의 수를, [매개변수 객체 만들기](매개변수객체만들기), [객체 통째로 넘기기](객체통째로넘기기)로는 매개변수의 수를 줄일 수 있다.
  - 위의 기법을 적용했음에도 여전히 임시변수와 매개변수가 많다면 [함수를 명령으로 바꾸기](함수를명령으로바꾸기)를 고려한다.
- 추출할 코드 덩어리는 주석을 추적하면 좋다.
  - 보통 코드만으로 목적을 이해하기 어려운 부분에 주석이 있기 때문이다.
  - 주석이 설명하는 코드를 함수로 추출하고, 함수의 이름은 주석의 내용을 토대로 짓는다.
- 조건문은 [조건문 분해하기](조건문분해하기)로 대응한다.
  - 거대한 switch문을 구성하는 case문 마다 [함수 추출하기](함수추출하기)를 적용하여 각 case의 본문을 함수 호출문 하나로 바꾼다.
  - 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 [조건문을 다형성으로 바꾸기](조건문을다형성으로바꾸기)를 적용한다.
- 반복문도 그 안의 코드와 함께 추출하여 독립된 함수로 만든다.
  - 추출한 반복문 코드에 적절한 이름이 떠오르지 않는다면 성격이 다른 여러 작업이 섞여있기 때문일수도 있다.
  - 이럴때는 과감히 [반복문 쪼개기](반복문_쪼개기)를 적용하여 작업을 분리한다.

### 4. 긴 매개변수 목록

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 [매개변수를 질의함수로 바꾸기](매개변수를질의함수로바꾸기)로 제거할 수 있다.
- 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 [객체 통째로 넘기기](객체통째로넘기기)를 적용해 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 [매개변수 객체 만들기](매개변수객체만들기)로 하나로 묶는다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 [플래그 인수 제거하기](플래그인수제거하기)로 없애준다.
- 여러 함수가 특정 매개변수들의 값을 공통으로 사용하고 있다면 [여러 함수를 클래스로 묶기](여러함수를클래스로묶기)를 이용해 공통 값들을 클래스의 멤버 변수로 정의한다.
  - 일련의 부분적용 함수를 생성하는 것과 비슷한 느낌.

### 5. 전역 데이터

- 전역 변수를 코드의 여기저기에서 접근하여 일방적인 수정이 가능하다면 버그를 추적하기 힘들어진다.
- [변수 캡슐화하기](변수캡슐화하기)를 이용해 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.
  - 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있게된다.
- 전역 데이터가 가변이라면...?
  - 전역 데이터를 가변으로 다뤄야하는 경우가...

### 6. 가변 데이터

- [변수 캡슐화하기](변수캡슐화하기)를 이용해 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 수정되는 것을 감시하거나 코드를 개선하기 쉽다.
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 [변수 쪼개기](변수쪼개기)를 이용해 용도별로 독립 변수에 저장한다.
- [함수 추출하기](함수추출하기)와 [문장 슬라이드하기](문장슬라이드하기)를 이용해 무언가를 갱신하는 코드로 부터 side effect가 없는 코드를 분리한다.
- API를 만들 때는 [질의 함수와 변경 함수 분리하기](질의함수와변경함수분리하기)를 활용해서 꼭 필요한 경우가 아니라면 side effect가 있는 코드를 호출할 수 없게 한다.
- [세터 제거하기](세터제거하기)는 변수의 유효범위를 줄이는데 도움이 될떄가 있다.
  - ? 맥락이 굉장히 생략되어있어 이해를 못하겠다.
- 값을 다른곳에서 설정할 수 있는 가변데이터는 특히 code smell이 심한 편에 속한다.
  - [파생 변수를 질의 함수로 바꾸기](파생변수를질의함수로바꾸기)를 이용한다.
- 변수의 유효범위가 단 몇줄이라면 가변 데이터라해도 문제를 일으킬 일이 별로 없다. 하지만 나중에 유효범위가 넓어질 수 있고, 그러면 위험도 덩달아 커진다.
  - [여러 함수를 클래스로 묶기](여러함수를클래스로묶기), [여러 함수를 변환 함수로 묶기](여러함수를변환함수로묶기)를 활용해 변수를 갱신하는 코드들의 유효범위를 제한한다.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면 [참조를 값으로 바꾸기](참조를값으로바꾸기)를 적용하여 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체한다.

### 7. 뒤엉킨 변경

- 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그부분만 수정할 수 있기를 바란다. 이렇게 할 수 없다면 `뒤엉킨 변경`과 `산탄총 수술`이라는 code smell이 풍긴다.
- 뒤엉킨 변경은 SRP가 제대로 지켜지지 않았을 때 발생한다.
  - 특정 모듈의 변경 원인이 하나가 아닐때 발생한다.
  - 서로 다른 맥락을 하나의 모듈에서 처리하려고 하는 경우가 대표적이다(DB 연동 - 금융상품처리).
  - 개발 초기에는 맥락 사이의 경계를 명확히 나누기 어렵기 때문에 발견하기 힘들수도 있다.
- 각 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.([단계 쪼개기](단계쪼개기))
- 각 맥락에 해당하는 적당한 모듈을 만들어서 코드에 퍼져있는 관련 함수들을 모은다.([함수 옮기기](함수옮기기))
  - 이때 여러 맥락에 관여하는 함수가 있다면 옮기기 전에 [함수 추출하기](함수추출하기)부터 수행한다.
  - 모듈이 클래스라면 [클래스 추출하기](클래스_추출하기)가 적당하다.

### 8. 산탄총 수술

- `산탄총 수술`은 `뒤엉킨 변경`과 비슷하면서도 정반대다.
  - 코드를 변경할때마다 자잘하게 수정해야하는 클래스가 많을 때 문제가 발생한다. 변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 수정할 곳을 지나치기 쉽다.
- 함께 변경되는 대상들을 [함수 옮기기](함수옮기기)와 [필드 옮기기](필드옮기기)로 한 모듈에 묶어두면 좋다.
- 비슷한 데이터를 다루는 함수가 많다면 [여러 함수를 클래스로 묶기](여러함수를클래스로묶기)를 적용한다.
- 데이터 구조를 변환하거나 보강하는 함수들에는 [여러 함수를 변환 함수로 묶기](여러함수를변환함수로묶기)를 적용한다.
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직에 전달할 수 있다면 [단계 쪼개기](단계쪼개기)를 적용한다.
- 어설프게 분리된 로직을 [함수 인라인하기](함수인라인하기)나 [클래스 인라인하기](클래스인라인하기)같은 방법을 적용한다.
- 메서드나 클래스가 비대해지지만, 나중에 추출하기 더 좋은 형태로 분리할 수도 있다.

|           | 뒤엉킨 변경             | 산탄총수술           |
| --------- | ----------------------- | -------------------- |
| 원인      | 맥락을 잘 구분하지 못함 | 좌동                 |
| 해법      | 맥락을 명확히 구분      | 좌동                 |
| 발생 과정 | 한 코드에 섞여 들어감   | 여러 코드에 흩뿌려짐 |
| 해결 방법 | 맥락별로 분리           | 맥락별로 모으기      |

### 9. 기능 편애

- 모듈화된 프로그램이 모듈간에 직교하지 않을때 발생한다.
  - 어떤 함수가 자신이 속한 모듈 내부와의 상호작용보다는 다른 모듈의 함수나 데이터와 상호작용이 더 많은 경우.
- 함수를 상호작용하는 부분과 더 가깝게 배치한다.([함수 옮기기](함수옮기기))
- 함수의 특정 부분만 그렇게 동작하는 경우 그 부분만 독립 함수로 빼내어([함수 추출하기](함수추출하기)) 원하는 모듈로 옮긴다.
- 어디로 옮길지가 명확하게 드러나지 않는경우, [함수 추출하기](함수추출하기)로 함수를 여러 조각으로 나누어 각각의 적합한 모듈로 보낸다.
  - 예를 들어, 함수가 사용하는 모듈이 다양한 경우가 그렇다.

### 10. 데이터 뭉치

- `데이터 뭉치`를 판별하는 방법은 값 하나를(객체의 프로퍼티를 의미하는 듯) 삭제했을때 나머지 데이터만으로 의미가 없는 경우이다. 이 경우 클래스로 만들어 주면 좋다.
- 필드 형태의 데이터 뭉치를 찾아서 [클래스 추출하기](클래스추출하기)로 하나의 객체로 묶는다.
- 메서드 시그니처에 있는 데이터 뭉치는 [매개변수 객체 만들기](매개변수객체만들기), [객체 통째로 넘기기](객체통째로넘기기)를 적용해 매개변수의 수를 줄여본다.
  - 이렇게 되면 메서드 호출 코드가 간결해 진다.
- 데이터 뭉치를 간단한 레코드 구조가 아닌 클래스로 만들었따면, 그 클래스로 옮기면 좋을 동작은 없는지 살펴본다.

### 11. Primitive type 집착

- "금액"을 그냥 number 타입으로 계산하거나 "물리량"을 계산할 때 `mm`, `inch`등의 단위를 무시하는 경우.
- 특히 문자열을 다루는 코드에서 특히 흔하다.
  - 예를 들어 전화번호를 단순히 문자 집합으로만 표현하는 것.
- [Primitive type을 객체로 바꾸기](기본형을객체로바꾸기)를 적용한다.
- Primitive type으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면, [타입 코드를 서브 클래스로 바꾸기](타입코드를서브클래스로바꾸기)와 [조건부 로직을 다형성으로 바꾸기](조건부로직을다형성으로바꾸기)를 차례로 적용한다.
- 자주 함께 몰려다는 primitive type 그룹도 `데이터 뭉치`다.
  - 따라서 [클래스 추출하기](클래스추출하기), [매개변수 객체 만들기](매개변수객체만들기)를 적용한다.

### 12. 반복되는 switch문

- 반복되는 switch문은 [조건부 로직을 다형성으로 바꾸기](조건부로직을다형성으로바꾸기)를 적용하여 처리한다.
  - 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중한다.
- 중복된 switch문은 조건이 하나 추가될때마다 다른곳의 switch문들도 모두 수정해야하기 때문에 문제가 된다.
  - 다형성은 이러한 문제를 잘 해결할 수 있다.

### 13. 반복문

- [반복문을 파이프라인으로 바꾸기](반복문을파이프라인으로바꾸기)를 적용해 반복문을 제거한다.
  - `filter`, `map`같은 파이프 라인 연산을 통해 코드의 의도를 쉽게 전달할 수 있다.

### 14. 성의 없는 요소

- 함수, 클래스, 인터페이스등이 의미없이 사용되고 있다면 과감히 정리한다.
  - 메서드가 하나뿐인 클래스, 본문 코드를 그대로 사용하는 함수 등
- [함수 인라인하기](함수인라인하기)나 [클래스 인라인하기](클래스인라인하기)로 처리한다.
- 상속을 사용했다면 [계층 합치기](계층합치기)를 적용한다.

### 15. 추측성 일반화

- "나중에 필요할 거야"라는 생각으로 당장은 필요 없는 모든 종류의 hooking point와 특이 케이스 처리 로직을 작성해 둔 것을 말한다.
  - 이해하거나 관리하기 어렵게 된다. 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만 그렇지 않다면 정리한다.
- 하는 일이 거의 없는 추상 클래스는 [계층 합치기](계층합치기)를 적용한다.
- 쓸데없이 위임하는 코드는 [함수 인라인하기](함수인라인하기)나 [클래스 인라인하기](클래스인라인하기)로 처리한다.
- 본문에서 사용되지 않는 매개변수는 [함수 선언 바꾸기](함수선언바꾸기)로 처리한다.
- 테스트 코드 말고는 사용되는 곳이 없다면 테스트 케이스부터 삭제한 뒤 [죽은 코드 제거하기](죽은코드제거하기)로 처리한다.

### 16. 임시 필드

- 특정한 상황에서만 값이 설정되는 필드를 가진 클래스의 경우.
  - 보통 객체를 가져올 떄는 당연히 모든 필드가 채워져 있으리라 기대하기 때문에, 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.
- 임시 필드들은 [클래스 추출하기](클래스추출하기)를 이용해 분리한다.
- 그 다음 [함수 옮기기](함수옮기기)를 이용해 임시 필드들과 관련한 코드를 전부 새로운 클래스에 넣는다.
- 임시 필드들이 유효한지를 확인 한 후 동작하는 조건부 로직은 [특이 케이스 추가하기](특이케이스추가하기)로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거한다.

### 17. 메시지 체인

- 메시지 체인은 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

```ts
const managerName = person.department.manager.name;
```

- 이 문제는 [위임 숨기기](위임숨기기)로 해결한다.
  - 중간 객체들이 모두 중개자가 돼버리기 쉽기 때문에 최종 결과 객체가 어떻게 쓰이는지 부터 살펴보는게 좋다.
- [함수 추출하기](함수추출하기)로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 [함수 옮기기](함수옮기기)로 체인을 숨길 수 있는지 살펴본다.

```ts
const managerName = person.department.manager.name;

/**
 * person 클래스 혹은 department 클래스에 부서장 이름을 바로 반환하는 메서드를 추가하여
 * "위임 숨기기"를 적용하여 체인을 줄일 수 있다.
 * */
const managerName = person.department.managerName;
const managerName = person.manager.name;
const managerName = person.managerName;

// 혹은 이 체인이 report를 생성하는 로직에 필요하다면 아래와 같은 형태로 모듈 속으로 체인을 숨긴다.
const report = reportGenerator.report(person);
```

### 18. 중개자

- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 [중개자 제거하기](중개자제거하기)를 활용해 실제로 일을 하는 객체와 직접 소통하게 한다.
- 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인한다.([함수 인라인하기](함수인라인하기))

### 19. 내부자 거래

- 모듈 사이의 데이터 거래가 많으면 그 양을 최소로 줄이고 모두 투명하게 처리해야한다.
- 은밀하게 데이터를 주고받는 모듈들이 있다면, [함수 옮기기](함수옮기기)와 [필드 옮기기](필드옮기기) 기법으로 떼어놓아 사적으로 처리하는 부분을 줄인다.
- 여러 모듈이 같은 관심사를 공유한다면 공통된 부분을 정식으로 처리하는 제 3의 모듈을 새로 만들거나 [위임 숨기기](위임숨기기)를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
- 상속 구조에서, 자식 클래스가 부모클래스에 대해 필요 이상으로 접근해야하는 경우 [서브클래스를 위임으로 바꾸기](서브클래스를위임으로바꾸기)나 [슈퍼클래스를 위임으로 바꾸기](슈퍼클래스를위임으로바꾸기)를 활용한다.

### 20. 거대한 클래스

- 한 클래스가 너무 많은 일을 하려다보면 필드가 늘어나고, 중복코드가 생기기 쉽다.
- 이럴때는 [클래스 추출하기](클래스추출하기)로 필드들의 일부를 따로 묶는다.
  - 묶는 필드는 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택한다.
- 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 클래스를 추출하기 보다는 [슈퍼클래스 추출하기](슈퍼클래스추출하기)나 (실질적으로 서브클래스 추출하기에 해당하는) [타입 코드를 서브 클래스로 바꾸기](타입코드를서브클래스로바꾸기)를 적용하는 편이 더 쉽다.
- 코드량이 너무 많은 클래스도 중복코드가 생기기 쉬워진다.
  - 일단 그 클래스 안에서 자체적으로 중복을 제거한다.
- 클라이언트들이 거대한 클래스를 어떻게 이용하는지 패턴을 파악하여 그 클래스를 어떻게 나눌지 단서를 얻을수도 있다.
  - 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살피고, 이 기능 그룹을 기준으로 개별 클래스로 추출한다.

### 21. 서로 다른 인터페이스의 대안 클래스들

- 필요에 따라 언제든 다른 클래스로 교체할 수 있어야하는데, 교체하려면 인터페이스가 같아야 한다.
  - 따라서 [함수 선언 바꾸기](함수선언바꾸기)로 메서드 시크니처를 일치시킨다.
  - 이것만으로 부족할 경우 [함수 옮기기](함수옮기기)를 이용해 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어넣는다.
  - 그러다 대안 클래스들 사이에 중복코드가 생기면 [슈퍼클래스 추출하기](슈퍼클래스추출하기)를 적용할지 고민해본다.

### 22. 데이터 클래스

- 데이터 클래스란 데이터 필드, getter, setter로만 구성된 클래스를 말한다.
  - 데이터 저장 용도로만 쓰다보니 다른 클래스가 너무 깊은곳까지 함부로 다룰때가 많다.
  - 이런 클래스에 public 필드가 있다면 얼른 [레코드 캡슐화하기](레코드캡슐화하기)로 숨긴다.
  - 변경하면 안되는 필드는 [세터 제거하기](세터제거하기)로 접근을 막는다.
- 다른 클래스에서 데이터 클래스의 getter, setter를 사용하는 메서드를 찾아서 [함수 옮기기](함수옮기기)로 그 메서드를 데이터 클래스 내부로 옮길수 있는지 살펴본다.

  - 메서드를 통째로 옮기기 어렵다면 [함수 추출하기](함수추출하기)를 이용해서 옮길 수 있는 부분만 별도 메서드로 뽑아낸다.

- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다. 이런 경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.
  - 예외도 있는데 특히 다른 함수를 호출해 얻은 `결과 레코드(데이터 객체)`로는 동작 코드를 넣을 이유가 없다.
  - 대표적인 예시가 `단계 쪼개기`의 결과로 나온 중간 데이터 구조인데 이런 데이터 구조는 immutable이다.
  - Immutable 필드는 굳이 캡슐화할 이유가 없다.

### 23. 상속 포기

- 서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 그것을 원하지않거나 필요 없는 경우 서브클래스 하나를 새로 만들고, [메서드 내리기](메서드내리기)와 [필드 내리기](필드내리기)를 활용해 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 옮긴다.
  - 이렇게 하면 부모 클래스에는 공통된 부분만 남는다.
- 하지만 저자는 위의 방식을 권하지 않는다.
- 서브 클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을때 발생한다. 이럴떄는 (서브클래스를위임으로바꾸기)나 [슈퍼클래스를 위임으로 바꾸기](슈퍼클래스를위임으로바꾸기)로 상속에서 벗어난다.

### 24. 주석

- 주석을 code smell을 없애기 위한 탈취제처럼 사용하면 안된다.
  - 주석이 장황하게 달린 원인은 코드를 잘못 작성했기 때문이다.
- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 [함수 추출하기](함수추출하기)를 적용한다.
- 이미 추출되어있는 함수임에도 여전히 설명이 필요하다면 [함수 선언 바꾸기](함수선언바꾸기)로 함수 이름을 바꿔본다.
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 [assertion 추가하기](assertion추가하기)를 이용한다.
- **주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 refactoring해본다.**

## 2. 논의하고 싶은 것

- `23. 상속포기`는 와닿지 않는다.
- `여러 함수를 클래스로 묶기`는 직접 경험해 본 것이라 공감이 아주 잘되는거 같다.
- `뒤엉킨 변경`, `산탄총 수술`은 component개발 시 많이 느낀 부분이다. 특히 mobile 대응할떄라든가...
- `반복문을 파이프라인으로 바꾸기`는 정말 추천해주고 싶은 방법이다. 경험상 '어떻게'하는지를 작성하는 것 보다 '무엇을'하는지를 작성하는 것이 다른사람이 쉽게 이해하는 거 같았다. 내 기준으로 회사의 코드를 약간 refactoring 해보자면 다음과 같이 할거 같다.

  ```ts
  generateOrgCode(): string {
    const codeLength = 3;
    const alphabets = 'ABCDEFGHJKLMNPQRSTUVWXYZ'.split('');
    const generatedCode = Array.from(Array(codeLength))
      .map(() => {
        const index = Math.floor(Math.random() * alphabets.length);
        return alphabets[index];
      })
      .join('');

    return generatedCode;
  }

  // ====> Refactoring
  const alphabets = 'ABCDEFGHJKLMNPQRSTUVWXYZ'

  const getRandomIndex = () => _.random(0, alphabets.length - 1)

  const getRandomAlphabet = () => alphabets[getRandomIndex()]

  const generateOrgCode = () => {
    const ORG_CODE_LENGTH = 3;
    const generatedCode = _.times(ORG_CODE_LENGTH, getRandomAlphabet)
    return generatedCode.join('')
  }
  ```

- 책에서도 전제하고 있긴 하지만 애초에 데이터를 immutable하게 다루면 일어나지 않을 일들이 있는거 같다.

## 3. 앞으로 진행되어야 할 후속작업

- 링크(추후 내용을 정리하면 해당 log file의 url을 바꿔준다.)
  - 함수선언바꾸기
  - 변수이름바꾸기
  - 필드이름바꾸기
  - 함수추출하기
  - 문장슬라이드하기
  - 메서드올리기
  - 메서드내리기
  - 임시변수를질의함수로바꾸기
  - 매개변수객체만들기
  - 객체통째로넘기기
  - 함수를명령으로바꾸기
  - 조건문분해하기
  - 조건문을다형성으로바꾸기
  - 매개변수를질의함수로바꾸기
  - 플래그인수제거하기
  - 여러함수를클래스로묶기
  - 변수캡슐화하기
  - 변수쪼개기
  - 질의함수와변경함수분리하기
  - 세터제거하기
  - 파생변수를질의함수로바꾸기
  - 여러함수를변환함수로묶기
  - 참조를값으로바꾸기
  - 단계쪼개기
  - 함수옮기기
  - 필드옮기기
  - 필드내리기
  - 함수인라인하기
  - 클래스인라인하기
  - 클래스추출하기
  - 기본형을객체로바꾸기
  - 타입코드를서브클래스로바꾸기
  - 조건부로직을다형성으로바꾸기
  - 반복문을파이프라인으로바꾸기
  - 계층합치기
  - 죽은코드제거하기
  - 특이케이스추가하기
  - 위임숨기기
  - 중개자제거하기
  - 서브클래스를위임으로바꾸기
  - 슈퍼클래스를위임으로바꾸기
  - 슈퍼클래스추출하기
  - 레코드캡슐화하기
  - assertion추가하기
