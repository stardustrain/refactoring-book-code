# 2. Refactoring 원칙

## 1. 주요 내용 정리

### 1. Refactoring 정의

- 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.
  - `겉보기 동작`이라 함은, refactoring 전과 후의 코드가 똑같아야 한다는 뜻이다.
  - 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다. 다만, Refactoring 과정에서 발견된 버그는 그대로 남아있어야 한다.
- Refactoring하다가 코드가 깨져서 며칠이나 고생했다면, 그것은 refactoring한 것이 아니다.
- Refactoring은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다.

### 2. 두 개의 모자

- 기능 추가와 refactoring을 명확하게 구분해야한다.
  - 기능 추가를 할 때는 기존 코드를 건드리지 않고 새 기능을 추가하기만 한다.
  - Refactoring을 할 때는 기능을 추가하지 않고 코드 재구성에만 전념한다.
- 전체 작업 시간이 짧다고 해도 지금 내가 무엇을 하고 있는 것인지 명확하게 구분한다.

### 3. Refatoring을 하는 이유

- Refactoring이 모든 문제점을 해결하는 만병통치약은 아니다. 하지만 **코드를 건강한 상태로 유지하는 것을 도와주는 약**임은 분명하다.

1. 설계가 좋아진다.

   - 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
   - **코드만으로 설계를 파악하기 어려워진다.** 개발자간의 context가 사라지면 코드만 남기 때문에 정말 중요한 문제.
   - 코드만으로 설계를 파악하기 어려워지면 설계 자체를 유지하기 어려워진다.
   - 같은 일을 하더라도 설계가 나쁘면 코드가 길어진다. 사실상 비슷한 로직이 코드 여러곳에 나타날 수 있기 때문에. 그래서 *중복 코드 제거*는 중요하다.

2. 이해하기 쉬워진다.

   - 다른 개발자(혹은 내가 될수도 있는)가 내 코드를 이해하지 못하고 한시간 걸릴 일을 일주일이나 걸려 해결한다면 문제가 있다고 봐야한다.
   - 프로그램을 동작시키는 데만 신경 쓰다 보면 정작 그 코드를 다룰 개발자를 배려하지 못한다.
   - 의도를 더 명확하게 전달하도록 코드를 작성하는 것이 중요하다.

3. 버그를 쉽게 찾을 수 있다.

   - 코드를 이해하기 쉽다면 버그를 찾기도 쉽다.

4. 개발 속도를 높일 수 있다.
   - Refactoring 할 당시의 시간소모가 아닌 소프트웨어의 전체 life cycle을 놓고 보았을때, 이해하기 쉬운 코드는 기능의 추가, 수정, 삭제를 쉽게 만들어 준다.
   - `지구력 가설`. 내부 설계가 잘 된 코드는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 오래 지속할 수 있다.

### 4. 언제 하는가?

- 3의 법칙
  - 처음에는 그냥한다. > 비슷한 일을 두 번째로 하게 되면 일단 계속 한다. > 비슷한 일을 세 번째 하게 되면 refactoring 한다.

1. 기능을 쉽게 추가하게 만들기
   - Refactoring 하기 가장 좋은 시점은 새로운 기능을 추가하기 직전이다.
   - 현재의 구조를 살펴보면서 만약 바꾼다면 다른 작업을 하기 수월해질 만한 부분을 찾는다. 예를들어 오류를 일으키는 코드가 세 곳에 복제되어 퍼져있다면 우선 한곳으로 합친다든가...
2. 코드를 이해하기 쉽게 만들기
   - 코드를 파악할 때 마다 의도를 더 명확하게 드러나도록 refactoring 할 여지가 없는지 찾아본다.
   - if 조건을 파악하고, 변수와 함수의 이름을 고민하고 긴 함수를 잘게 나눈다.
3. 쓰레기 줍기 refactoring (Litter-Pickup Refactoring)
   - 코드 파악 중 비효율적으로 일을 처리하는 모습을 발견했다면 refactoring한다.
   - 단, 절충이 필요한데 간단한 수정이라면 즉시 고치고, 그렇지 않다면 메모를 남겨놓고 원래 하던 일을 끝내고 처리한다.
4. 계획된 refactoring, 수시로 하는 refactoring
   - Refactoring은 프로그래밍과 구분되는 별개의 활동이 아니다.
   - 코드가 지저분하든 잘 작성되었든 refactoring의 여지가 보이면 한다.
   - 무언가 수정하려고 할 때는 먼저 수정하기 쉽게 정돈하고 그 다음 쉽게 수정한다.
   - 계획된 refactoring이 무조건 나쁜것이 아니다. 다른 이유때문에 refactoring에 소홀했다면, 따로 시간을 내어 기능을 추가하기 쉽도록 코드를 개선한다.
     - 하지만 계획된 refactoring을 하게 되는 일은 최소한으로 줄여야 한다. Refactoring은 기회가 될때마다 해야한다.
   - VCS를 사용한다면 refactoring과 기능 추가 commit을 분리하지 않아도 된다.
     - 두 작업이 밀접하게 엮인 경우가 많고, commit을 분리하면 refactoring의 맥락을 파악하기 힘들다.
     - 팀에 맞는 적합한 방식을 찾는다.
5. 오래 걸리는 refactoring
   - 팀 전체가 달려들어 몇 주 걸리는 대규모 refactoring의 경우 팀 전체가 refactoring을 진행하는것은 회의적이다(작가의 생각).
   - 주어진 문제를 몇주에 걸쳐 조금씩 해결하는 편이 효과적일 때가 많다.
     - 누구든지 refactoring 해야 할 코드와 관련한 작업을 하게 될때마다 조금씩 개선하는 식.
6. 코드리뷰에 refactoring 활용하기
   - Pair programming이 효과적일수도 있다!
7. 관리자에게는 뭐라고 해야할까?
   - 관리자가 refactoring의 중요성을 잘 알고있다면 진행하면 된다.
   - 관리자가 refactoring의 중요성을 모른다면 "refactoring한다고 말하지 말라"고 작가는 이야기하고 있다.
     - 개발자는 프로이기 때문에 일정과 refactoring 사이에서 구체적인 방법을 판단해야한다.
8. Refactoring 하지 말아야할 때
   - 지저분 하더라도 굳이 수정할 필요가 없는 경우.
     - 내부 동작을 이해해야할 시점에서 하는것이 효과가 좋다.
   - 처음부터 새로 작성하는 것이 더 쉬울 경우.

### 5. 고려할 문제

1. 새 기능 개발 속도 저하
   - Refactoring의 목적은 개발 속도를 높여서 더 적은 노력으로 더 많은 가치를 창출하는 것임을 잊지 않는다.
   - 다만, 상황에 맞게 조율해야하는데 새로운 기능 추가와 refactoring 간의 균형을 잘 찾아야 한다.
   - **Refactoring을 '클린 코드' 혹은 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화 하는것은 위험하다.** Refactoring의 본질은 코드를 예쁘게 꾸미는 것이 아닌 *개발 기간 단축*에 있음을 항상 명심ㅂ해야 한다.
2. 코드 소유권
   - 코드의 소유권을 팀에 두어, 필요할때 필요한곳의 코드에 접근가능하도록 한다.
   - 만약 대규모 시스템 개발시 특정 영역에 대한 코드가 팀 별로 분리되어있다면, 브랜치를 따서 PR을 요청하는 오픈소스 방식도 괜찮다.
3. 브랜치
   - 브랜치의 통합주기를 짧게 가져간다.
   - CI에 따르면 모든 팀원들은, 자신의 작업 branch를 하루에 최소 한번은 main branch와 통합해야 한다.
   - 거대한 기능을 잘 나누어 개발하는 법을 배우고, 각 기능을 활성화 할 수 있는 기능 플래그를 적용하여 완료되지 않은 기능이 시스템을 망치게 하지 않는다.
4. 테스팅
   - Refactoring 시 오류를 재빠르게 잡기 위해서는 코드의 다양한 측면을 검사하는 test suite가 필요하다.
   - 이 test suite는 빠르고 쉽게 동작해야한다. (jest, mocha의 wathc mode가 이상적인듯)
5. 레거시
   - 레거시를 파악할 때 refactoring이 굉장한 도움이 된다.
   - 만약 테스트가 없다면 테스트를 보강하며 진행하면 도움이 된다.
   - 레거시를 refactoring 하는 방법에 대한 정답은 없으며, "레거시 코드 활용 전략(에이콘, 2018)"에 나온 지침을 충실히 따른다.
   - 테스트를 갖추고 있더라도 복잡하게 얽힌 레거시를 한번에 refactoring 할 수 없다.
     - 이 경우 분할정복 전략이 도움이 된다.
     - 코드의 한 부분을 읽을때마다 보이스카웃 원칙을 떠올리며 조금씩 refactoring 한다.
6. 데이터베이스

### 6. Refactoring, 아키텍쳐, YAGNI

- 요구사항을 사전에 완벽하게 파악하여 아키텍쳐에 적용하기란 불가능에 가깝다.
  - Refactoring은 요구사항의 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다.
- 요구사항의 변화에 유연하게 대처하도록 유연성 메커니즘을 소프트웨어에 심어둘 수는 있지만 상당히 조심해야한다. 다양한 시나리오에 대응하기 위해 매개변수를 추가하는 방법이 적당한 예시가 될 수 있다.
  - 당장의 쓰임에 비해 코드 복잡도가 증가한다.
  - 요구사항이 완전히 뒤바뀔수도 있다.
  - 유연성 메커니즘 자체에 결함이 존재할 수도 있다.
- 그렇기 때문에 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 이것을 YAGNI (You Aren't Going to Need It.)이라고 한다.
  - 선제적인 아키텍처 고민에 소홀해도 된다는 뜻은 아니다!
  - Refactoring으로 변경하기 어려워 미리 생각해 두면 시간이 절약되는 경우, 선제적으로 대응한다. 이 균형점을 잘 찾아야 한다.
- 그럼에도 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다고 생각한다.(작가의 생각)

### 7. Refactoring과 소프트웨어 개발 프로세스

- 첫 번째 토대는 테스트 코드이다.
- CI는 각 개발자의 작업 결과를 빠르게 공유할 수 있다.
- 테스트 코드, CI, refactoring은 서로 강력한 상승작용을 일으킨다. 이 세가지 방법을 적용하면 YAGNI 설계 방식으로 개발을 진행할 수 있다.

### 8. Refactoring과 성능

- 코드를 다루기 쉬운 형태로 유지해야 성능 튜닝도 수월하게 할 수 있다.
- 프로파일러를 통해 문제의 원인을 찾아내어 그 부분을 개선한다.
  - Refactoring이 잘 되어있다면 기능 추가가 빨리 끝나기 때문에 성능에 집중할 시간을 더 벌수있다.
  - Refactoring이 잘 되어있다면 프로파일러가 지적하는 코드의 범위가 더 좁을 것이고 튜닝하기 쉬워진다.
- Refactoring의 영향으로 성능이 느려질 수 있지만 최적화 단계에서 성능 튜닝이 쉽기 때문에 이득을 얻게 된다.

## 2. 논의하고 싶은 것

- 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다. 다만, Refactoring 과정에서 발견된 버그는 그대로 남아있어야 한다.

  - 책에서는 두 부류의 버그를 구분하고 있는데, 이를 어떻게 구분해야할까?
  - 아무도 발견하지 못한 숨은 버그를 수정해서 함수의 동작이 달라진다면 이는 refactoring했다고 할 수 있을까?

- 전체 작업 시간이 짧다고 해도 지금 내가 무엇을 하고 있는 것인지 명확하게 구분한다.
  - 왜일까? 어렴풋한 "느낌"만 있어서 다른 사람들의 생각이 궁금해졌다.
